"""
Data models for calendar application using Pydantic.

This module defines the core data structures for our application using Pydantic.

Why Pydantic?
- Automatic data validation (catches bugs early)
- Type safety (prevents runtime errors)
- JSON serialization/deserialization
- Clear documentation through type hints
- Integration with modern Python frameworks

Architecture Pattern: Domain Models
- Each class represents a real-world entity
- Validation rules ensure data integrity
- Relationships between entities are clearly defined
"""
#This file is used to clean and validate the data that is generated by the LLM 

from datetime import datetime
from typing import List, Optional, Literal
from pydantic import BaseModel, EmailStr, Field, validator


class WorkingHours(BaseModel):
    """Model for user's working hours."""
    start: str = Field(..., description="Start time in HH:MM format")
    end: str = Field(..., description="End time in HH:MM format")
    
    @validator('start', 'end')
    def validate_time_format(cls, v):
        """Validate time format is HH:MM."""
        try:
            datetime.strptime(v, "%H:%M")
            return v
        except ValueError:
            raise ValueError("Time must be in HH:MM format")


class UserPreferences(BaseModel):
    """Model for user preferences."""
    working_hours: WorkingHours
    meeting_duration_preference: str = Field(..., description="Preferred meeting duration")
    calendar_view: Literal["day", "week", "month"] = "week"


class User(BaseModel):
    """
    Model for a calendar user - represents a person who uses the calendar system.
    
    This is our main entity that contains all user information including preferences.
    The LLM will generate realistic data for each field based on the prompts.
    
    Design decisions:
    - user_id is optional because it's auto-generated by the system
    - email uses EmailStr for automatic validation
    - preferences is a nested object for better organization
    - created_at tracks when the user was generated
    """
    # System-generated unique identifier (auto-generated if not provided)
    user_id: Optional[str] = None  
    
    # Basic user information (required fields)
    name: str = Field(..., min_length=1, max_length=100, description="Full name of the user")
    email: EmailStr  # Automatically validates email format
    timezone: str = Field(..., description="User's timezone (e.g., 'America/New_York')")
    profession: str = Field(..., min_length=1, max_length=100, description="User's job title")
    
    # Nested preferences object (contains working hours, etc.)
    preferences: UserPreferences
    
    # Metadata (auto-generated)
    created_at: Optional[datetime] = None  # When this user was created
    
    def __str__(self):
        """Human-readable representation for debugging and logging."""
        return f"User({self.name}, {self.email})"


class CalendarEvent(BaseModel):
    """Model for a calendar event."""
    event_id: Optional[str] = None  # Will be generated
    user_id: str = Field(..., description="ID of the user who owns this event")
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    start_time: datetime = Field(..., description="Event start time")
    end_time: datetime = Field(..., description="Event end time")
    location: Optional[str] = Field(None, max_length=200)
    attendees: List[EmailStr] = Field(default_factory=list)
    category: Literal["meeting", "appointment", "personal", "work"] = "meeting"
    priority: Literal["high", "medium", "low"] = "medium"
    recurrence: Optional[str] = Field(None, description="Recurrence pattern")
    created_at: Optional[datetime] = None
    
    @validator('end_time')
    def end_time_after_start_time(cls, v, values):
        """Ensure end time is after start time."""
        if 'start_time' in values and v <= values['start_time']:
            raise ValueError('End time must be after start time')
        return v
    
    def __str__(self):
        return f"Event({self.title}, {self.start_time.strftime('%Y-%m-%d %H:%M')})"


class GenerationStats(BaseModel):
    """Model for tracking generation statistics."""
    users_generated: int = 0
    events_generated: int = 0
    total_api_calls: int = 0
    failed_generations: int = 0
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    
    @property
    def duration_seconds(self) -> Optional[float]:
        """Calculate generation duration in seconds."""
        if self.start_time and self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return None


class GenerationBatch(BaseModel):
    """Model for a batch of generated data."""
    batch_id: str
    users: List[User] = Field(default_factory=list)
    events: List[CalendarEvent] = Field(default_factory=list)
    stats: GenerationStats = Field(default_factory=GenerationStats)
    provider_used: Literal["openai", "deepseek"]
    created_at: datetime = Field(default_factory=datetime.now) 